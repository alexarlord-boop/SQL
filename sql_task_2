

/****** ******/
Задача 1 (Зачтено)
Ответ: 	Уникальный кластерный индекс первичного ключа,
	Уникальный некластерный индекс по столбцу Email,
	Некластерный Индекс idx_Employees_TabNum для столбца TabNum на основе столбца кластеризованной таблицы Employees,
	Возможно среди 20 полей есть поля с модификатором UNIQUE – для них будет создан некластерный индекс.



Задача 2 (Зачтено)
Ответ:
	1)Почему поиск с использованием индекса по полю TabNum для данного запроса – это хорошо?
	-индексы эффективны на численных типах(сортировка,сравнение, небольшое число страниц).
	
	2)Почему поиск с использованием индекса по полю TabNum для данного запроса – это плохо?
	-значения TabNum не уникальны, подсистема хранения данных добавляет к дублирующему значению целочисленное значение, 
	которое увеличивает размер ключа, что может стать проблемой при большом количестве дубликатов, 
	а эти значения станут основой некластеризованного индекса или ссылкой внешнего ключа.
	
	3)Что надо сделать, чтобы запрос с использованием индекса гарантированно давал преимущества по сравнению с неиспользованием индекса?
	-сделать покрывающий индекс на основе поля Email с дополнительно включенными полями /
	-сделать составной индекс по полям запроса. Например(Email, LastName).
	


Задача 3
Ответ:
	В запросе используется функция DATEPART. 
	Эта функция возвращает целое число, представляющее указанную часть datepart заданного типа date. 
	Чтобы найти строки, подходящие под условие WHERE, необходимо просканировать кластерный индекс и вычислить значение этой функции. 
	Индекс по дате не даст преимущества.
	
	Что сделать: задать границы для даты в условии: DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01'.
		     Добавить это в условие отфильтрованного индекса.
		     Итого:
			CREATE INDEX idx_Employees_DateOfBirth ON Employees(DateOfBirth)
			WHERE DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01';

			SELECT COUNT(*)
			FROM Employees
			WHERE DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01';



Задача 4
Ответ:
	Повысит скорость исполнения, все поля запроса содержатся в индексе.
	
	Что сделать: добавить условие LastName =N'Иванов' в отфильтрованный индекс, добавить модификатор сортировки DESC в индекс после поля DateOfBirth.
		     Итого:
			CREATEINDEX idx_Employees_LastName_DateOfBirth ON Employees(LastName, DateOfBirth DESC)
			WHERE LastName =N'Иванов';
			
			SELECT TOP 1 *
			FROM Employees
			WHERE LastName =N'Иванов'
			ORDERBY DateOfBirth DESC
	


Задача 5
Ответ:
	Некорректный индекс, не даст преимущества. Включает ненужное поле на обслуживание, понизит скорость.
	
	Что сделать: убрать поле LastName из индекса. Сделать отфильтрованный  индекс с условием DateOfBirth >'2000-01-01'. 
		    Итого:
			CREATE INDEX idx_Employees_DateOfBirth ON Employees(DateOfBirth)
			WHERE DateOfBirth >'2000-01-01';
			
			SELECT *
			FROM Employees
			WHERE DateOfBirth >'2000-01-01'





Задача 6 (Зачтено)
Ответ:
	-Снизит скорость исполнения. Поле LastName не покрывается индексом. 
	Поиск строк, удовлетворяющих аргументу из неиндексированного поля будет 
	проводиться через полное сканирование всех строк таблицы, 
	что может оказать значительное влияние на производительность.
