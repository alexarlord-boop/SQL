
/****** Скрипт для схемы БД  ******/
---DROP DATABASE Sales

CREATE DATABASE Sales;
USE Sales;

CREATE TABLE [Customer](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	LastName nvarchar(50) NOT NULL,
	MiddleName nvarchar(50) DEFAULT NULL,
	FirstName nvarchar(50) NOT NULL,
	Gender nchar(1) NOT NULL,
	City nvarchar(100) NOT NULL,
	AddressLine1 nvarchar(100) NOT NULL
);

CREATE TABLE [Currency](
	CurrID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	Currency nvarchar(10) NOT NULL
);

CREATE TABLE [Product](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	ProductName nvarchar(50) NOT NULL,
	ListPrice decimal NOT NULL,
	Currency int NOT NULL FOREIGN KEY REFERENCES Currency(CurrID)
);

CREATE TABLE [Designation](
	DesID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	Designation nvarchar(10) NOT NULL
);

CREATE TABLE [Order](
	OrderID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	CustomerID int NOT NULL FOREIGN KEY REFERENCES Customer(ID),
	TotalPrice decimal NOT NULL,   
	Currency int NOT NULL FOREIGN KEY REFERENCES Currency(CurrID),
	OrderDate datetime NOT NULL
);

CREATE TABLE [OrderBill](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	OrderID int NOT NULL FOREIGN KEY REFERENCES Order(OrderID),
	ProductID int NOT NULL FOREIGN KEY REFERENCES Product(ID),
	SoldUnitPrice decimal NOT NULL,
	ProductQty int NOT NULL,
	Designation int NOT NULL FOREIGN KEY REFERENCES Designation(DesID)
);


SET IDENTITY_INSERT Designation ON;
INSERT INTO Designation(DesID, Designation) Values(1, 'шт'),(2, 'м3'),(3, 'м.п.');
SET IDENTITY_INSERT Designation OFF;
GO

SET IDENTITY_INSERT Currency ON;
INSERT INTO Currency(CurrID, Currency) Values(1, 'р');
SET IDENTITY_INSERT Currency OFF;
...



/****** ******/
Задача 1
Ответ: 	Уникальный кластерный индекс первичного ключа,
	Уникальный некластерный индекс по столбцу Email,
	Некластерный Индекс idx_Employees_TabNum для столбца TabNum на основе столбца кластеризованной таблицы Employees,
	Возможно среди 20 полей есть поля с модификатором UNIQUE – для них будет создан некластерный индекс.



Задача 2
Ответ:
	1)Почему поиск с использованием индекса по полю TabNum для данного запроса – это хорошо?
	-индексы эффективны на численных типах(сортировка,сравнение, небольшое число страниц).
	
	2)Почему поиск с использованием индекса по полю TabNum для данного запроса – это плохо?
	-значения TabNum не уникальны, подсистема хранения данных добавляет к дублирующему значению целочисленное значение, 
	которое увеличивает размер ключа, что может стать проблемой при большом количестве дубликатов, 
	а эти значения станут основой некластеризованного индекса или ссылкой внешнего ключа.
	
	3)Что надо сделать, чтобы запрос с использованием индекса гарантированно давал преимущества по сравнению с неиспользованием индекса?
	-сделать покрывающий индекс на основе поля Email с дополнительно включенными полями /
	-сделать составной индекс по полям запроса. Например(Email, LastName).
	


Задача 3
Ответ:
	В запросе используется функция DATEPART. 
	Эта функция возвращает целое число, представляющее указанную часть datepart заданного типа date. 
	Чтобы найти строки, подходящие под условие WHERE, необходимо просканировать кластерный индекс и вычислить значение этой функции. 
	Индекс по дате не даст преимущества.
	
	Что сделать: задать границы для даты в условии: DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01'.
		     Добавить это в условие отфильтрованного индекса.
		     Итого:
			CREATE INDEX idx_Employees_DateOfBirth ON Employees(DateOfBirth)
			WHERE DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01';

			SELECT COUNT(*)
			FROM Employees
			WHERE DateOfBirth > '1998-01-01' AND DateOfBirth < '1999-01-01';



Задача 4
Ответ:
	Повысит скорость исполнения.
	
	Что сделать: добавить условие LastName =N'Иванов' в отфильтрованный индекс, добавить модификатор сортировки DESC в индекс после поля DateOfBirth.
		     Итого:
			CREATEINDEX idx_Employees_LastName_DateOfBirth ON Employees(LastName, DateOfBirth DESC)
			WHERE LastName =N'Иванов';
			
			SELECT TOP 1 *
			FROM Employees
			WHERE LastName =N'Иванов'
			ORDERBY DateOfBirth DESC
	


Задача 5
Ответ:
	Некорректный индекс, не даст преимущества.
	Что сделать: убрать поле LastName из индекса. Сделать отфильтрованный  индекс с условием DateOfBirth >'2000-01-01'. 
		    Итого:
			CREATE INDEX idx_Employees_DateOfBirth ON Employees(DateOfBirth)
			WHERE DateOfBirth >'2000-01-01';
			
			SELECT *
			FROM Employees
			WHERE DateOfBirth >'2000-01-01'





Задача 6
Ответ:
	-Снизит скорость исполнения. Поле LastName не покрывается индексом. 
	Поиск строк, удовлетворяющих аргументу из неиндексированного поля будет 
	проводиться через полное сканирование всех строк таблицы, 
	что может оказать значительное влияние на производительность.
