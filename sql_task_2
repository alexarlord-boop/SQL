
/****** Скрипт для схемы БД  ******/
CREATE DATABASE Sales;
USE Sales;

CREATE TABLE [Customer](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	LastName nvarchar(30) NOT NULL,
	FirstName nvarchar(30) NOT NULL,
	Gender nvarchar(10) NOT NULL,
	AddressLine nvarchar(30) NOT NULL
);

CREATE TABLE [Product](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	ProductName nvarchar(30) NOT NULL,
	Price int NOT NULL
);

CREATE TABLE [OrderDetails](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	ProductID int NOT NULL FOREIGN KEY REFERENCES Product(ID),
	ProductQty int NOT NULL,
	TotalPrice int NOT NULL
);

CREATE TABLE [Order](
	ID int IDENTITY(1,1) NOT NULL PRIMARY KEY,
	CustomerID int NOT NULL FOREIGN KEY REFERENCES Customer(ID),
	OrderDetailsID int NOT NULL FOREIGN KEY REFERENCES OrderDetails(ID),
	OrderDate datetime NOT NULL
);




/****** ******/
Задача 1
Ответ: 	Уникальный кластерный индекс первичного ключа,
	Уникальный некластерный индекс по столбцу Email,
	Некластерный Индекс idx_Employees_TabNum для столбца TabNum на основе столбца кластеризованной таблицы Employees,
	Возможно среди 20 полей есть поля с модификатором UNIQUE – для них будет создан некластерный индекс.

Задача 2
Ответ:
	1)Почему поиск с использованием индекса по полю TabNum для данного запроса – это хорошо?
	-индексы эффективны на численных типах(сортировка,сравнение, небольшое число страниц).
	
	2)Почему поиск с использованием индекса по полю TabNum для данного запроса – это плохо?
	-значения TabNum не уникальны, подсистема хранения данных добавляет к дублирующему значению целочисленное значение, 
	которое увеличивает размер ключа, что может стать проблемой при большом количестве дубликатов, 
	а эти значения станут основой некластеризованного индекса или ссылкой внешнего ключа.
	
	3)Что надо сделать, чтобы запрос с использованием индекса гарантированно давал преимущества по сравнению с неиспользованием индекса?
	-сделать покрывающий индекс на основе поля Email с дополнительно включенными полями /
	-сделать составной индекс по полям запроса. Например(Email, LastName).
	


Задача 3
Ответ:
	-так как столбец не имел индекса, скорость исполнения запроса повысится.
	-определить действительно нужные столбцы и указать вместо *, добавить их в индекс /
	-заменить условие DATEPART(YEAR, DateOfBirth)= 1998 /
 	на YEAR(DateOfBirth)=1998 и сохранить данные столбца DateOfBirth через PERSISTED /
	-Создать некластерный покрывающий индекс на позволяющие это сделать поля в таблице Employees.



Задача 4
Ответ:
	-повысит скорость исполнения, так как дает возможность отменить сортировку строк на выходе
	-поменять порядок колонок (DateOfBirth, LastName), и проверить 
	(улучшения будут, если колонка DateOfBirth обладает более высокой селективностью) /
	-определить действительно нужные столбцы и указать вместо *, добавить их в покрывающий индекс.



Задача 5
Ответ:
	- так как в запросе задействованы поле из индекса, скорость исполнения повысится. 
	- определить действительно нужные столбцы и указать вместо *, добавить их в покрывающий индекс.



Задача 6
Ответ:
	-Снизит скорость исполнения. Поле LastName не покрывается индексом. 
	Поиск строк, удовлетворяющих аргументу из неиндексированного поля будет 
	проводиться через полное сканирование всех строк таблицы, 
	что может оказать значительное влияние на производительность.
